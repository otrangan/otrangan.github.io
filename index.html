<html>
<head>
  <title>Vertex pi-floodlight</title>
</head>

<body>
<div style="max-width: 700">
<h1 style="text-align:center">1 Introduction</h1>
<p>
  In this project, we design an interactive tutorial to study the upper bound of illuminating a simple polygon with n vertices, k of which are convex, using edge-aligned vertex pi-floodlight.
</p>
<p>                
  Usually, a partition of the space into convex regions, each of which is visible by one guard, allows one to use a combinatorial argument on a finite set of possible guard locations.
</p>
<p>
  In contrast, our allocation of guards is based on a decomposition of a simple polygon into pseudo-triangles—planar polygons with exactly three convex vertices 
  <a name="ref1">[1]</a>.
  <a href = "Applet.html">Applet</a>
</p>
<h1 style="text-align:center">2 Definitions</h1>
<p>
  In this part, we introduce some definitions which have been or will be used in this project.
</p>
<h2>2.1	Edge-aligned vertex pi-floodlight</h2>
<p>
  (1)	The range of illumination of each floodlight is restricted to π.
</p>
<p>
  (2)	The floodlights are placed at the vertices of the polygon.
</p>
<div style="text-indent:2em">
<p>
  The floodlights which satisfy (1)(2) are called vertex pi-floodlight. A vertex pi-floodlight is given by a pair (v, H<sup>v</sup>) where v is a vertex of polygon P and H<sup>v</sup> is a closed half-plane 
  such that v is on the boundary of H<sup>v</sup>.
</p>
<p>
  A pi-floodlight (v, H<sup>v</sup>) illuminates a ∈ P if and only if the closed line segment va is in P ∩ H<sup>v</sup>.
</p>
<p>
  It is obvious that a pi-floodlight at a reflex vertex cannot monitor the complete angular domain bounded by the two incident sides.
</p>
<p>
  It is defined that at every reflex vertex v, the possible pi-floodlight (v, H<sup>v</sup>) is <i>edge-aligned</i> if:
</p>
</div>
<p>
  (3) The floodlight is inward-facing and the boundary of H<sup>v</sup> is collinear 
  with one of the sides incidents to v <a name="ref1">[1]</a>.
</p>
<p>
  For a reflex vertex v of a pseudo-triangle we consider only vertex pi-guards which are inward-facing (as defined above) or outward-facing, that is, the sides of P incident to v are in the closed half-plane H<sup>v</sup>.
</p>
<p>
  For a corner v, we consider only two possibilities: either (v, H<sup>v</sup>) completely covers the angular domain, or it does not cover it at all, that is, we ignore partial coverage.
</p>
<h2>2.2	Monotone mountains</h2>
<p>
  Monotone mountains <a name="ref1">[6]</a> are a family of polygons with two chains of reflex vertices.
</p>
<h2>2.3	Geodesic path</h2>
<p>
  About the geodesic path, there is firstly a theorem proposed by Johann Bernoulli in 1698.
</p>
<p>
  <b>Theorem: </b>(Bernoulli, 1698) The shortest path between two points on a surface is a geodesic path.
</p>
<p>
  In this project, we restrict ourselves to the simpler case in which our surface of interest is a simple planar polygon. In this case a <i>geodesic path</i> is defined to be the <i>shortest</i> <u>internal</u> path connecting two points in the polygon and it is unique <a name="ref1">[2]</a>.
</p>
<p>
  And the <i>geodesic path between two vertices of the polygon</i> is the shortest path that connects the vertices and stay completely in the polygon <a name="ref1">[3]</a>.
</p>
<h2>2.4	Pseudo-triangulations</h2>
<p>
  As shown in the introduction, a pseudo-triangle T is a simple polygon with exactly three convex vertices, called <i>corners</i>. If a, b and c are the corners of T in <i>counter-clockwise</i> order, then we denote by <span style="text-decoration: overline">ab</span> (and similarly by <span style="text-decoration: overline">bc</span> and <span style="text-decoration: overline">ca</span>) the chain of <i>reflex</i> vertices between a and b in counter-clockwise direction on the boundary of T.
</p>
<p>
  For a simple polygon P, a <i>pseudo-triangulation</i> is a set D of non-overlapping pseudo-triangles such that P = &cup;D and vertices of pseudo-triangles are vertices of P. Since triangles are also pseudo-triangles, any triangulation of a simple polygon is also a pseudo-triangulation <a name="ref1">[1]</a>.
</p>
<h3>2.4.1	Pointed pseudo-triangulations</h3>
<p>
  In this project we consider exclusively <i>pointed pseudo-triangulations</i>. A pointed pseudo-triangulation is a pseudo-triangulation with the <i>minimum</i> number of pseudo-triangular faces.
</p>
<h3>2.4.2	Geodesic triangulations</h3>
<p>
  Pointed pseudo-triangulations are also referred to as geodesic triangulations, since every pseudo-triangulation can be obtained by dissecting P along non-crossing geodesic paths connecting convex vertices. This approach will be introduced in detail in this webpage.
</p>
<h2>2.5	Dual graph</h2>
<p>
  The dual graph G(D) of a pseudo-triangulation D is defined by choosing D as the node set of G(D) and connecting two nodes by an edge iff the corresponding pseudotriangles share a side (a diagonal of P). If D is a pseudo-triangulation of a simple polygon, then G(D) is a <i>tree</i>.
</p>
<p>
  Let x &isin; V(P) be a convex vertex of P and let y &isin; V(P) be a vertex adjacent to x.We denote by G(D)<sub>xy</sub> the rooted tree G(D) where the root R corresponds to the pseudo-triangle containing side xy. We write S&lt;T for two pseudo-triangles S, T &isin; D<sub>xy</sub> if T is the <i>ancestor</i> of S in G(D)<sub>xy</sub>. For example, S &lt; R for all pseudo-triangles S &ne; R. As a shorthand, we denote by D<sub>xy</sub> the pseudo-triangulation D together with the partial order of ancestor relationships in the tree G(D)<sub>xy</sub>.
</p>
<h1 style="text-align:center">3	Illuminating a pseudo-triangle</h1>
<p>
  To prove the upper bound on the number of edge-aligned vertex pi-floodlights we first show how to illuminate a single pseudo-triangle with &lfloor;(2n-3)/3&rfloor; vertex pi-floodlights and then generalize this approach to a pseudo-triangulation of a simple polygon.
</p>
<p>
  There are two propositions <a name="ref1">[1]</a> corresponds to two different kinds of pseudo-triangles: monotone mountains or not.
</p>
<img src="images/pseudo_triangle.png" alt="Image removed" width="400" />
<p>
  <b>Proposition 1.</b> A pseudo-triangle T with l vertices can be monitored by at most &lfloor;(2l-3)/3&rfloor; vertex pi-guards: one at a corner and at most &lfloor; 2(l-3) / 3&rfloor; outward-facing guards at reflex vertices along two chains.
</p>
<div style="text-indent:2em">
  <p>
    <i>Proof.</i> Observe that one guard at a corner and <i>outward</i>-facing guards along the two adjacent chains can monitor the complete pseudo-triangle. For the three corners, this gives three possible guard allocations jointly using a total of 3+2(l-3)=2l-3 guards. This implies that at least one guard allocation uses at most &lfloor; 2(l-3) / 3&rfloor; guards (see the above figure (left))
  </p>
</div>
<p>
  <b>Proposition 2.</b> A pseudo-triangle abc with l vertices and <span style="text-decoration: overline">bc</span>=&empty; can be monitored by at most &lfloor; (l-1) / 2&rfloor; vertex pi-guards: one at the corner b or c (but not at both) and at most &lfloor; (l-3) / 2&rfloor; outward-facing guards at reflex vertices along a chain different from <span style="text-decoration: overline">bc</span>.
</p>
<div style="text-indent:2em">
  <p>
    <i>Proof.</i> Consider the two guard allocations which put one pi-guard at corner b (resp., c) and outward-facing pi-guards at vertices along the adjacent chain ba (resp., ca). Both monitor   T and jointly use a total of l-1 guards (see the above figure (right)).
  </p>
</div>
<h1 style="text-align:center">4	Balanced geodesic triangulation</h1>
<p>
  In order to generate the upper bound of number of floodlights for one pseudo-triangle to a simple polygon, we need to decompose the polygon into pseudo-triangle. To do that, there are many methods proposed <a name="ref1">[3]</a><a name="ref1">[4]</a><a name="ref1">[5]</a>. In this project, we will use the so called balanced geodesic triangulation in reference <a name="ref1">[3]</a>.
</p>
<h2>4.1	Algorithm</h2>
<p>
  Algorithmically, the decomposition is built in some <i>recursive</i> stages. 
</p>
<p>
  In the first stage, we choose three vertices of the polygon that are equally spaced around the boundary of the polygon and we connect them with geodesic paths. Specifically, if v<sub>1</sub>, v<sub>2</sub>, ……, v<sub>n</sub> are the vertices of P, we compute the geodesic paths connecting v<sub>1</sub>, v<sub>&lfloor;n/3&rfloor;</sub>, v<sub>&lfloor;2n/3&rfloor;</sub>, as well as v<sub>1</sub> and v<sub>&lfloor;2n/3&rfloor;</sub>.
</p>
<p>
  In the second stage, we repeat the same operation but now we connect the pairs (v<sub>1</sub>, v<sub>&lfloor;n/6&rfloor;</sub>), (v<sub>&lfloor;n/6&rfloor;</sub>, v<sub>&lfloor;n/3&rfloor;</sub>), (v<sub>&lfloor;n/3&rfloor;</sub>, v<sub>&lfloor;n/2&rfloor;</sub>), etc
</p>
<p>
  We iterate on this process until the geodesic paths connect pairs of vertices that are only one vertex apart.
</p>
<h2>4.2	Construction example</h2>
<p>
  In this section, we will give a detailed construction example on an arbitrary simple polygon P. Before the construction, we number the vertices of P.
</p>
<img src="images/numbered.png" alt="Image removed" width="400" />
<p>
  (1)We compute geodesic paths connecting the pairs(v<sub>1</sub>, v<sub>6</sub>), (v<sub>6</sub>, v<sub>12</sub>), (v<sub>12</sub>, v<sub>1</sub>).
</p>
<img src="images/stage1.png" alt="Image removed" width="400" />
<p>
  (2)We compute geodesic paths connecting the pairs (v<sub>1</sub>, v<sub>3</sub>), (v<sub>3</sub>, v<sub>6</sub>), (v<sub>6</sub>, v<sub>9</sub>), (v<sub>9</sub>, v<sub>12</sub>), (v<sub>12</sub>, v<sub>15</sub>), (v<sub>15</sub>, v<sub>1</sub>).
</p>
<img src="images/stage2.png" alt="Image removed" width="450" />
<p>
  We compute geodesic paths connecting the pairs (v<sub>1</sub>, v<sub>3</sub>), (v<sub>3</sub>, v<sub>4</sub>), (v<sub>4</sub>, v<sub>6</sub>), (v<sub>6</sub>, v<sub>7</sub>), (v<sub>7</sub>, v<sub>9</sub>), (v<sub>9</sub>, v<sub>10</sub>), (v<sub>10</sub>, v<sub>12</sub>), (v<sub>12</sub>, v<sub>13</sub>), (v<sub>13</sub>, v<sub>15</sub>), (v<sub>15</sub>, v<sub>16</sub>), (v<sub>16</sub>, v<sub>1</sub>).
</p>
<img src="images/stage3.png" alt="Image removed" width="420" />
<p>
  In this stage, we add a new path between pairs (v<sub>17</sub>, v<sub>1</sub>).
</p>
<img src="images/stage4.png" alt="Image removed" width="400" />
<p>
  We find that the geodesic paths connect pairs of vertices are only one vertex apart. We stop the algorithm and get the balanced geodesic triangulation of P.
</p>
<h2>4.3 Construction application</h2>
<p>
  We have implemented a JavaScript program to implement the <a href='https://rhmcl.csb.app/'>balanced geodesic triangulation</a>. Left click to draw points in the canvas and click the 'pseudo-tr'button to get the balanced geodesic triangulation of the polygon.
</p>
<h1 style="text-align:center">5	Illuminating a simple polygon</h1>
<h2>5.1 Proof of upper bound [1]</h2>
<p>
  <b>Theorem:</b> &lfloor;(2n-k)/3&rfloor; edge-aligned vertex pi-guards can always monitor a simple polygon with n vertices, k of which are convex. 
</p>
<div style="text-indent:2em">
  <p>
    <i>Proof.</i> Following, and generalizing the idea of Proposition 1, we describe three different guard allocations for p that jointly use a total of 2n − k edge-aligned vertex pi-guards. We define these allocations with respect to an arbitrary but fixed pseudo-triangulation D<sub>xy</sub>. In all three guard allocations and for each pseudo-triangle T &isin; D<sub>xy</sub>, there will be vertex pi-guards at one corner of T and along the two chains adjacent to that corner such that these general guards collectively monitor T . The three guard allocation schemes will jointly use all three corners (and thus different pairs of chains) for each T &isin; D<sub>xy</sub>.
  </p>
</div>
<img src="images/direction_propagate.png" alt="Image removed" width="400"/>
<p>
  Consider the pseudo-triangle T<sub>1</sub> at the root of G(D)<sub>xy</sub>. We can guard T<sub>1</sub> in three different ways by choosing any one of its three corners and placing guards at that corner (the <i>guarded corner</i> gc(T<sub>1</sub>) of T<sub>1</sub>) and along its two adjacent chains. Every choice of guard allocation for T<sub>1</sub> induces a <i>direction</i> on its chains: the sides on the chains adjacent to gc(T<sub>1</sub>) are directed <i>away</i> from gc(T<sub>1</sub>), the sides on the remaining chain have <i>no</i>> direction. Note that we do indeed distinguish between three directions for each side—the two standard directions and no direction. Fixing the direction for one side of a pseudo-triangle <i>uniquely</i>> determines the directions for the remaining ones. Each side of the pseudo-triangulation can only have one direction, i.e., a pseudo-triangle inherits its directions from its parent via their <u>joined side</u>. Therefore, choosing a guarded corner gc(T<sub>1</sub>) in T<sub>1</sub> not only induces a unique direction on the sides of T<sub>1</sub>, but actually determines the direction of all sides of D<sub>xy</sub> (see the figure above). Since every pseudo-triangle $T$ now has exactly one corner with two outgoing directed sides, we define this corner to be the guarded corner gc(T). Note that for each corner v of every T &isin; D<sub>xy</sub> there is a choice of the guarded corner of T<sub>1</sub>, such that the resulting orientation of D<sub>xy</sub> implies that $v$ is the guarded corner of T.
</p>
<p>
  After choosing gc(T<sub>1</sub>) and propagating the directions along G(D)<sub>xy</sub>, we place vertex pi-guards along the directed sides of D<sub>xy</sub>. More specifically, in each T &isin; D<sub>xy</sub> we place a vertex pi-guard at the corner gc(T) and <i>outward-facing</i> pi-guards along the two directed chains adjacent to gc(T<sub>1</sub>). By Proposition 1, these general guards collectively monitor T . Note that it is always sufficient to place at most one pi-guard at each vertex since every vertex is a reflex vertex of at most one pseudo-triangle of D<sub>xy</sub> and pi-guards at reflex vertices are outward-facing. (This already gives an upper bound of &lfloor;(2 n-k) / 3&rfloor; in the general model.)
</p>
<p>
  Next we align every vertex pi-guard (v,H<sup>v</sup>) at every reflex vertex v with one of the sides of P incident to v. Recall that v is a reflex vertex of exactly one T<sub>v</sub> &isin; D<sub>xy</sub>. We placed a guard at v only if v is incident to a side s<sub>in</sub> of T<sub>v</sub> directed to v and a side s<sub>out</sub> of T<sub>v</sub> directed away from v (i.e., v lies on a chain adjacent to  gc(T<sub>v</sub>). Let D<sub>xy</sub><sup>v</sup> be the set of all other pseudo-triangles of D<sub>xy</sub> incident to v, every T &isin; D<sub>xy</sub><sup>v</sup> has a corner at v. Note that gc(T)=v for every pseudo-triangle T &isin; D<sub>xy</sub><sup>v</sup> separated from T<sub>v</sub> by s<sub>out</sub>, because if one side of T incident to v is directed away from v, then both sides are directed that way. Similarly,  gc(T)=v for every pseudo-triangle T &isin; D<sub>xy</sub><sup>v</sup> separated from T<sub>v</sub> by s<sub>in</sub>. Now for every reflex vertex v align the pi-guard at v with the incident side of P directed away from v. The resulting edge-aligned pi-guard at v monitors at least as much area of T<sub>v</sub> as before, and it monitors the full angular domain of every T &isin; D<sub>xy</sub><sup>v</sup> whose guarded corner is v. So after alignment, the resulting set of vertex pi-guards still monitors every T &isin; D<sub>xy</sub><sup>v</sup>.
</p> 
<p>
  Finally, we show that the total number of guards is 2n-k. We use 2l<sub>1</sub>-3 guards on the boundary of the pseudo-triangle T<sub>1</sub> corresponding to the root of D<sub>xy</sub>, where l is the number of vertices of T<sub>1</sub>. For all other T<sub>i</sub> &isin; D<sub>xy</sub> with l<sub>i</sub> vertices, two guards out of the 2l<sub>i</sub>-3 are already counted on the boundary of the ancestor of T<sub>i</sub>. (This can be easily checked for all possible mutual positions of two adjacent pseudo-triangles: i.e., the common vertices are both corners, both reflex, or one is a corner and the other one is reflex.) Hence all three guard allocations use a total of 2+&sum;<sup>p</sup><sub>i=1</sub>2l<sub>i</sub>-5 = 2-5p+2&sum;<sup>p</sup><sub>i=0</sub>l<sub>i</sub> guards where p denotes the number of pseudo-triangles, i.e., p=k-2. Since n-2 = &sum;<sup>p</sup><sub>i=1</sub>(l<sub>i</sub>-2) = (&sum;<sup>p</sup><sub>i=1</sub>l<sub>i</sub>)-2p, we obtain 2n−2−p = 2n−k guards in total.
</p>
<h2>5.2 Illumination tutorial</h2>
<p>
  Based on the geodesic triangualtion obtained above, now we can place the floodlight according to some rules.
</p>
<h3>5.2.1 Floodlight placment</h3>
<p>
  According to the proof above, consider the pseudo-triangle T<sub>1</sub> at the root of G(D)<sub>xy</sub>, we can choose a guarded corner gc(T<sub>1</sub>) of  T<sub>1</sub> which can induce a direction of its chains, the chains adjacent to the guarded corner is directed away from the corner, the side on the remaining chain has no direction.
</p>
<p>
  Fixing the direction for one side of a pseudo-triangle uniquely determines the directions for the remaining ones. Each side of the pseudo-triangulation can only have one direction, i.e., a pseudo-triangle inherits its directions from its parent via their joined side.
</p>
<p>
  In each T &isin; D<sub>xy</sub> we place a vertex pi-guard at the corner gc(T) and outward-facing pi-guards along the two directed chains adjacent to gc(T).
</p>
<p>
  Note that it is always sufficient to place at most one pi-guard at each vertex since every vertex is a reflex vertex of at most one pseudo-triangle of D<sub>xy</sub> and pi-guards at reflex vertices are outward-facing.
</p>
<h3>5.2.2 Floodlight alignment</h3>
<p>
  we align every vertex pi-guard (v,H<sup>v</sup>) at every reflex vertex v with one of the sides of P incident to v.
</p>
<h1 style="text-align:center">6 References</h1>
<p>
  <a href="https://link.springer.com/article/10.1007/s00454-004-1091-9#ref1">1.	Speckmann, B. , & Csaba D. Tóth, Allocating vertex π-guards in simple polygons via pseudo-triangulations. Discrete & Computational Geometry, 33(2), (2005), 345-364.</a>
</p>
<p>
  <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.56.9862">2.	G. T. Toussaint, Computing geodesic properties inside a simple polygon, Rev. Intell. Artific. 3 (1989), 9–42.</a>
</p>
<p>
  <a href="https://link.springer.com/article/10.1007/BF01377183">3.	B. Chazelle, H. Edelsbrunner, M. Gringi, L. J. Guibas, J. Hershberger, M. Sharir, and J. Snoeyink, Ray shooting in polygons using geodesic triangulations, Algorithmica 12 (1994), 54–68.</a>
</p>
<p>
  <a href="#ref4">4.	Har-Peled, Sariel (2002), A comment on pseudo-triangulation in three dimensions(https://web.archive.org/web/20060912041048/http://valis.cs.uiuc.edu/~sariel/papers/02/ptriang/), archived from the original (http://valis.cs.uiuc.edu/~sariel/papers/02/ptriang/) on 2006-09-12, retrieved 2007-04-12.</a>
</p>
<p>
  <a href="https://www.researchgate.net/publication/47842408_Counting_and_Enumerating_Pointed_Pseudotriangulations_with_the_Greedy_Flip_Algorithm">5.	Brönnimann, Hervé; Kettner, Lutz; Pocchiola, Michel; Snoeyink, Jack (2006), "Counting and enumerating pointed pseudotriangulations with the greedy flip algorithm", SIAM Journal on Computing, 36 (3): 721–739.</a>
</p>
<p>
  <a href="https://dblp.uni-trier.de/rec/conf/cccg/ORourke97.html">6. J. O’Rourke, Vertex π-lights for monotone mountains, in: Proc. 9th Canadian Conf. Comput. Geom.(Kingston, ON, 1997), pp. 1–5.</a>
</p>
</div>
</body>
</html>

